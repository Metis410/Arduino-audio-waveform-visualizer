
#include <TFT_eSPI.h>
#include <SPI.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include "test_font.h"


#define ONE_WIRE_BUS 20
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);
TFT_eSPI tft = TFT_eSPI();
TFT_eSprite sprite = TFT_eSprite(&tft);

void setup(void) {

  pinMode(21, INPUT);
  pinMode(20, INPUT);
  Serial.begin(9600);

  sensors.begin();

  tft.init();
  tft.setRotation(-3);
  tft.fillScreen(0);



  sprite.createSprite(240, 135);
  sprite.loadFont(testfont);
  sprite.setTextDatum(4);
  // ledcSetup(0, 10000, 8);
  // ledcAttachPin(38, 0);
  // ledcWrite(0, 140);



  analogReadResolution(12);
  logo();
  delay(1500);
}

void draw() {
  //sprite.fillSprite(0);
  sprite.drawString("123v", 240 / 2, 135 / 2);
  sprite.pushSprite(0, 0);
}


unsigned long snap1;
unsigned long snap2;
int fr = 0;
bool clear = false;
void loop() {

  // draw();

  if (touch() == true) {
    snap1 = FR_snapS();
  }

  if (touch() == true) {
    if (clear == false) {  //clearuing screen before displaying
      tft.fillScreen(0);
      clear = true;
    }
    battdis(fr);
    extradis();
    cosmic_pattern();
  } else {
    disaudio();
    clear = false;  //reset
  }

  if (touch() == true) {
    snap2 = FR_snapE();
    fr = FR_cal(snap1, snap2);
  }
}




unsigned long FR_snapS() {
  return millis();
}

unsigned long FR_snapE() {
  return millis();
}

int FR_cal(unsigned long snap1, unsigned long snap2) {
  int framerate = (1000.0 / (snap2 - snap1));
  //tft.setTextSize(1);
  //tft.setCursor(3, 3);
  //tft.setTextColor(0xffff, 0);
  //tft.println(framerate);
  return framerate;
}

unsigned long wait;
unsigned long wait1 = 0;
unsigned long wait2 = 0;
bool stop;
int zoom_d = 0;
int zoom_d2 = 0;
int adjust_d = 0;
int avg = 1;
int adjust = 0;
bool run_once = false;
int analog3;
int scale_state = 20;
int scale = 4095 / scale_state;

void disaudio() {
  int arr[1];
  int zoom = analogRead(1) / 204.8 + 1.0;  // max 20 states //scale // when you use poten the higher the number ther tighter it will be, it will jump number apply to all pot
  int adjust_for_max_scale = 20;           // when max scale wave shift out of center
  arr[0] = 68;

  for (int i = -1 - zoom; i <= 240; i += zoom) {

    wait = millis();

    if (zoom != zoom_d) {                    //displaying zoom when its detected
      tft.drawFastVLine(i, 20, 20, 0x9492);  // draw spacing line
      tft.setCursor(0, 0);
      tft.setTextSize(2);
      tft.setTextColor(0xffff);
      tft.println(zoom);
      if (wait1 == 0 || zoom != zoom_d2) {
        wait1 = millis();  // intitial when ever the zoom change
        zoom_d2 = zoom;
      }
    }
    if (zoom != zoom_d) {
      if (wait >= wait1 + 2000) {  //wait 5 seconds before setting in
        zoom_d = zoom;
        wait1 = 0;
      }
    }

    if (analogRead(2) / scale_state >= (scale * adjust) / scale_state) {  // /25 are for just scaling, may or may not work
      (adjust++) * scale_state;
    }
    if (analogRead(2) / scale_state <= (scale * adjust) / scale_state) {
      (adjust--) * scale_state;
    }

    //adjust wave scale, +1 to stop it from going to zero
    int posamp = (analogRead(3) - avg - adjust_for_max_scale) / (adjust + 1);




    //auto adjust
    avg = ((analogRead(3) / 20 + avg / 20) / 2) * 20;  // reading avg to find a number for reduction




    if (adjust != adjust_d) {  // display scale when ever it detect it
      wait2 = millis();
      adjust_d = adjust;
      stop = false;
    }
    if (wait >= wait2 + 2000) {  // wait 2s before telling stop
      stop = true;
    }
    if (stop == false) {  //stop if true
      tft.setCursor(240 - 24, 135 - 15);
      tft.setTextSize(2);
      tft.setTextColor(0xffff);
      tft.println(adjust + 1);
    }


    if (run_once == false) {
      tft.setCursor(0, 135 - 15);
      tft.setTextSize(2);
      tft.setTextColor(0xffff);
      tft.println(avg);
      if (wait >= wait1 + 2000) {
        run_once = true;
      }
    }

    tft.fillRect(i + 1, 0, zoom, 135, 0);  //draw clearing line // must be one step ahead
    tft.drawFastHLine(i, 68, 1, 0x9492);   // draw mid line

    arr[1] = posamp;
    tft.drawLine(i, arr[0] + 68, i + zoom, arr[1] + 68, 0xfd00);  // draw connecting line from point
    arr[0] = arr[1];
  }
}

static const uint8_t PROGMEM metis[] = { 0xfc, 0x00, 0x00, 0x0f, 0x00, 0xf0, 0x03, 0xff, 0xff, 0x00, 0xff, 0xc3, 0xc3, 0xff, 0x00, 0xff,
                                         0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xc0, 0xfc, 0x00, 0x00, 0x0f, 0x00, 0xf0, 0x03, 0xff,
                                         0xff, 0x00, 0xff, 0xc3, 0xc3, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xc0,
                                         0xff, 0x00, 0x00, 0x3f, 0x00, 0xf0, 0x03, 0xff, 0xff, 0x00, 0xff, 0xc3, 0xc3, 0xff, 0x00, 0xff,
                                         0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xf0, 0xff, 0x00, 0x00, 0x3f, 0x00, 0xf0, 0x03, 0xff,
                                         0xff, 0x00, 0xff, 0xc3, 0xc3, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xf0,
                                         0xff, 0xc0, 0x00, 0xff, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
                                         0x03, 0xc0, 0x3f, 0x00, 0x3f, 0x00, 0x00, 0xfc, 0xff, 0xc0, 0x00, 0xff, 0x00, 0xf0, 0x00, 0x00,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x3f, 0x00, 0x3f, 0x00, 0x00, 0xfc,
                                         0xf3, 0xf0, 0x03, 0xff, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
                                         0x03, 0xc0, 0xfc, 0x00, 0x0f, 0xc0, 0x00, 0x3f, 0xf3, 0xf0, 0x03, 0xff, 0x00, 0xf0, 0x00, 0x00,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0xfc, 0x00, 0x0f, 0xc0, 0x00, 0x3f,
                                         0xf0, 0xfc, 0x0f, 0xcf, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
                                         0x03, 0xc3, 0xf0, 0x00, 0x03, 0xf0, 0x00, 0x0f, 0xf0, 0xfc, 0x0f, 0xcf, 0x00, 0xf0, 0x00, 0x00,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc3, 0xf0, 0x00, 0x03, 0xf0, 0x00, 0x0f,
                                         0xf0, 0x3f, 0x3f, 0x0f, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
                                         0x03, 0xc3, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x0f, 0xf0, 0x3f, 0x3f, 0x0f, 0x00, 0xf0, 0x00, 0x00,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc3, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x0f,
                                         0xf0, 0x0f, 0xfc, 0x0f, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
                                         0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x0f, 0xfc, 0x0f, 0x00, 0xf0, 0x00, 0x00,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
                                         0xf0, 0x03, 0xf0, 0x0f, 0x00, 0xf0, 0x00, 0xff, 0xff, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
                                         0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x03, 0xf0, 0x03, 0xf0, 0x0f, 0x00, 0xf0, 0x00, 0xff,
                                         0xff, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x03,
                                         0x00, 0x0f, 0xc0, 0x0f, 0x00, 0xf0, 0x03, 0xff, 0xff, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
                                         0x03, 0xc0, 0x00, 0x00, 0xc0, 0x03, 0xc0, 0x00, 0x00, 0x0f, 0xc0, 0x0f, 0x00, 0xf0, 0x03, 0xff,
                                         0xff, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xc0, 0x03, 0xc0, 0x00,
                                         0x00, 0x3f, 0x00, 0x0f, 0x00, 0xf0, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
                                         0x03, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x0f, 0x00, 0xf0, 0x0f, 0xc0,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
                                         0x00, 0xfc, 0x00, 0x0f, 0x00, 0xf0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03,
                                         0xc3, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x0f, 0x00, 0x00, 0xfc, 0x00, 0x0f, 0x00, 0xf0, 0x3f, 0x00,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc3, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x0f, 0x00,
                                         0x03, 0xf0, 0x00, 0x0f, 0x00, 0xf0, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x0f,
                                         0xc3, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x0f, 0xc0, 0x03, 0xf0, 0x00, 0x0f, 0x00, 0xf0, 0xfc, 0x00,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x0f, 0xc3, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x0f, 0xc0,
                                         0x0f, 0xc0, 0x00, 0x0f, 0x00, 0xf3, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x3f,
                                         0x03, 0xc0, 0x00, 0x00, 0xfc, 0x00, 0x03, 0xf0, 0x0f, 0xc0, 0x00, 0x0f, 0x00, 0xf3, 0xf0, 0x00,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x3f, 0x03, 0xc0, 0x00, 0x00, 0xfc, 0x00, 0x03, 0xf0,
                                         0x3f, 0x00, 0x00, 0x0f, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xfc,
                                         0x03, 0xc0, 0x00, 0x00, 0x3f, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x0f, 0x00, 0xff, 0xc0, 0x00,
                                         0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xfc, 0x03, 0xc0, 0x00, 0x00, 0x3f, 0x00, 0x00, 0xfc,
                                         0xfc, 0x00, 0x00, 0x0f, 0x00, 0xff, 0x03, 0xff, 0xff, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xff,
                                         0xff, 0xff, 0xff, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0x00, 0xff, 0x03, 0xff,
                                         0xff, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x0f, 0xff, 0xff, 0xff,
                                         0xf0, 0x00, 0x00, 0x0f, 0x00, 0xfc, 0x03, 0xff, 0xff, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xff,
                                         0xff, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0x00, 0xfc, 0x03, 0xff,
                                         0xff, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0xff };





void logo() {

  tft.drawBitmap(24, 51, metis, 192, 32, 0xffff);
  tft.drawFastHLine(24, 82 + 6, 192, 0x06df);
  tft.drawFastHLine(24, 82 + 12, 110 - 4, 0x06df);
  tft.setCursor(134, 82 + 12);
  tft.setTextSize(2);
  tft.setTextColor(0xfbf6);
  tft.println("Pre-Amp");
}

// 0xf45f light purple

int percentavg = 0;
float voltavg = 0;
void battdis(int fr) {
  float res1 = 30000;
  float res2 = 5100;
  float divide = res2 / (res1 + res2);

  for (int i = 1; i <= 50; i++) {
    float read = analogReadMilliVolts(0);
    float voltage = read / 1000.0 / divide;
    voltavg = voltavg + voltage;
  }
  voltavg = voltavg / 51;

  int percent = ((voltavg - 12.0) / 4.4) * 100.0;

  int percent10 = (percent - 1) / 10 * 10;

  if (percent <= percent10 + 10) {
    percent10 += 10;
  }
  //Serial.println(percent10);

  for (int i = 0; i < 240 * percent10 / 100; i++) {
    if ((i / 12) % 2 == 0) {
      tft.drawFastVLine(i + 3, 5, 20, 0xffff);  //draw
      if (i >= (240 * percent10 / 100) - 24) {
        tft.drawFastVLine(i + 3 + 24, 5, 20, 0);  // clear only at the top
      }
    }
  }

  tft.drawRect(0, 0, 228 + 7, 2, 0x06df);   // top line
  tft.drawRect(108 + 8, 0, 2, 28, 0x06df);  // mid line
  tft.drawRect(0, 28, 228 + 7, 2, 0x06df);  // bottom line
  tft.drawRect(228 + 6, 1, 2, 28, 0x06df);  // cap

  tft.setCursor(3, 33);
  tft.setTextSize(4);

  tft.setTextColor(0xf45f, 0);
  tft.print(percent);
  if (percent > 99) {
    tft.println("%");
  } else {
    tft.println("% ");
  }


  tft.setCursor(75 + 21, 33);
  tft.setTextColor(0xfd00, 0);
  tft.print(voltavg);
  tft.println("V");

  fpslock(30, fr);
  tft.flush();
}
int framedelay = 0;
float celci = 0;
int bar = 0;
int ohm = 0;
bool once = false;
void extradis() {
  avg = ((analogRead(3) / 20 + avg / 20) / 2) * 20;
  tft.setCursor(3, 135 - 15);
  tft.setTextSize(1);
  tft.setTextColor(0xffff, 0);
  tft.println(avg);

  int ohmgain = (-1880.0 + avg) * (100.0 / 2020.0) + 10.0;

  int ohmcolor = 0xfde0;

  tft.setCursor(32, 135 - 15);
  tft.setTextSize(2);
  tft.setTextColor(ohmcolor, 0);
  tft.print(ohmgain);
  if (ohmgain < 100) {
    tft.println("K ");
  } else {
    tft.println("K");
  }

  tft.fillRect(80 + 3, 120 + 6, float(ohmgain * 153.0 / 110.0), 3, ohmcolor);  // bar
  tft.fillRect(80 + float(ohmgain * 153.0 / 110.0) + 1, 120 + 6, 30, 3, 0);    // bar invert
  tft.drawRect(80 + 3, 120, 2, 15, ohmcolor);                                  //anchor S
  tft.drawRect(101 + 133, 120, 2, 15, ohmcolor);                               //anchor E
  tft.fillRect(101 + 135, 120, 6, 15, 0);                                      //anchor Clear

  //----------------------------------------------------------------------------------------------------------------

  ohm = ohmgain * 1000;

  // Serial.println("ohm % 10");
  // Serial.println(ohm % 10);
  // Serial.println(ohm % 100 / 10);
  // Serial.println(ohm % 1000 / 100);
  // Serial.println(ohm % 10000 / 1000);
  // Serial.println(ohm % 100000 / 10000);
  // Serial.println(ohm % 1000000 / 100000);
  int multy;
  int band3;
  int band2;
  int band1;

  if (ohm % 1000000 / 100000 == 0 && ohm % 100000 / 10000 != 0) {
    band1 = ohm % 100000 / 10000;
    band2 = ohm % 10000 / 1000;
    band3 = ohm % 1000 / 100;
    multy = 2;
  } else {
    band3 = ohm % 10000 / 1000;
    band2 = ohm % 100000 / 10000;
    band1 = ohm % 1000000 / 100000;
    multy = 3;
  }
  if (ohm % 100000 / 10000 == 0 && ohm % 1000000 / 100000 == 0) {
    band1 = ohm % 10000 / 1000;
    band2 = ohm % 1000 / 100;
    band3 = ohm % 100 / 10;
    multy = 1;
  }
  if (ohm % 10000 / 1000 == 0 && ohm % 100000 / 10000 == 0 && ohm % 1000000 / 100000 == 0) {
    band1 = ohm % 1000 / 100;
    band2 = ohm % 100 / 10;
    band3 = ohm % 10;
    multy = 0;
  }

  //(band1*100+band2*10+band3)*multy

  tft.fillRect(3, 135 - 7, 5, 7, resiscolor(band1));   //band1 1
  tft.fillRect(9, 135 - 7, 5, 7, resiscolor(band2));   //band2 2
  tft.fillRect(15, 135 - 7, 5, 7, resiscolor(band3));  //band3 .1
  tft.fillRect(21, 135 - 7, 5, 7, resiscolor(multy));  //multy

  //----------------------------------------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------------------------------------

  if (framedelay >= 60) {
    sensors.requestTemperaturesByIndex(0);
    sensors.setResolution(12);
    celci = sensors.getTempCByIndex(0);
    framedelay = 1;
    tft.fillRect(80, 101 + 6, 154, 3, 0);  // bar invert C
  }
  int celci_color = 0x5ecc;

  bar = framedelay / (60 / 154.0);

  tft.setCursor(3, 135 - 15 - 18);
  tft.setTextSize(2);
  tft.setTextColor(celci_color, 0);
  tft.print(celci);
  tft.setTextColor(celci_color, 0);
  tft.print("C");

  tft.drawRect(80 + 3, 101, 2, 15, celci_color);       //anchorS
  tft.fillRect(80 + 3, 101 + 6, bar, 3, celci_color);  // bar
  tft.drawRect(101 + 133, 101, 2, 15, celci_color);    //anchorE

  framedelay++;
  //----------------------------------------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------------------------------------

  //voltage range the preamp should be at around 15.4v to max
  // display "PAGVR 15.4v|       |  |16.4v"


  int anchor_pos = abs((15.6 - voltavg) * (106.0 / 0.8));

  //drawing should be in this order
  if (anchor_pos > 106) {
    anchor_pos = 106;  //limit in case of charging voltage going over
  }

  tft.fillRect(64 + anchor_pos, 84, 2, 15, 0);       //anchor clear
  tft.drawRect(66 + anchor_pos, 84, 2, 15, 0xffff);  //anchor moving
  tft.fillRect(68 + anchor_pos, 84, 2, 15, 0);       //anchor clear

  if (once == false) {
    tft.fillRect(64, 84, 109, 15, 0);  //remove odd line
    once = true;
  }


  tft.drawRect(64, 84, 2, 15, 0xfd20);   //anchorS
  tft.drawRect(174, 84, 2, 15, 0xfd20);  //anchorE

  tft.setCursor(3, 84);
  tft.setTextSize(2);
  tft.setTextColor(0xffe0, 0);

  tft.setCursor(3, 84);
  tft.print("15.6v");

  tft.setCursor(240 - 61, 84);
  tft.print("16.4v");


  //----------------------------------------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------------------------------------
  //----------------------------------------------------------------------------------------------------------------
}

unsigned long fade_time = 0;
unsigned long wait_time = 0;
bool switch_fade2 = true;
uint16_t fade = 0;

void cosmic_pattern() {
  float time = 4000.0;
  int wait_time = 2000;  // wait berfore glow down or glow up 1000 == 1s

  static const uint8_t PROGMEM CM_stat[] = { 0x00, 0x40, 0x02, 0x00, 0xc8, 0x00, 0x80, 0x01, 0xff, 0xfc, 0x01, 0xff, 0xfc, 0x00, 0x07, 0xe0,
                                             0x04, 0x01, 0x00, 0x00, 0x00, 0x10, 0x80, 0x80, 0x80, 0x01, 0x80, 0x40, 0x08, 0x80, 0x00, 0x40,
                                             0x02, 0x00, 0xc8, 0x00, 0x60, 0x03, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x0f, 0xf0, 0x04, 0x01,
                                             0x00, 0x00, 0x00, 0x10, 0x80, 0x80, 0xff, 0xf8, 0xc0, 0x40, 0x08, 0x80, 0xff, 0xfe, 0x02, 0x00,
                                             0xc8, 0xc0, 0x10, 0x06, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x38, 0x1c, 0x0e, 0x03, 0x00, 0x00,
                                             0x05, 0x30, 0x87, 0x00, 0x06, 0x04, 0x60, 0x40, 0x08, 0x80, 0x04, 0x03, 0x03, 0x00, 0xc8, 0xc0,
                                             0x10, 0x0c, 0x01, 0xfc, 0x00, 0x01, 0x01, 0x80, 0x30, 0x0c, 0x00, 0x06, 0x07, 0x19, 0xfd, 0xe0,
                                             0x88, 0x00, 0x0c, 0x02, 0x33, 0xf8, 0x08, 0x80, 0x04, 0x01, 0x81, 0x80, 0xc8, 0xc0, 0x60, 0x18,
                                             0x00, 0x00, 0x00, 0x01, 0x00, 0xc0, 0x60, 0x06, 0x0e, 0x0c, 0x02, 0x19, 0x05, 0x00, 0x8b, 0xff,
                                             0xf8, 0x02, 0x10, 0x00, 0x08, 0x80, 0x04, 0x00, 0xc0, 0xc0, 0xc8, 0xc0, 0x80, 0x30, 0x00, 0x10,
                                             0x00, 0x01, 0x00, 0x60, 0xc0, 0x07, 0x04, 0x08, 0x02, 0x19, 0x00, 0x01, 0x88, 0x00, 0x00, 0x02,
                                             0x10, 0x00, 0x19, 0x80, 0x04, 0x00, 0x60, 0x60, 0x98, 0xc0, 0x80, 0x60, 0x00, 0x10, 0x00, 0x01,
                                             0x00, 0x30, 0xc0, 0x03, 0x04, 0x08, 0x02, 0x19, 0x00, 0x03, 0x07, 0x00, 0x00, 0x04, 0x10, 0x00,
                                             0x33, 0x00, 0x08, 0x00, 0x30, 0x3f, 0x92, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                             0xc1, 0x83, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xfe, 0x00, 0x7f, 0xff, 0xf8, 0x90, 0x00, 0x66, 0x0f,
                                             0xf1, 0xff, 0xff, 0xff, 0x92, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x18, 0x0f, 0xff, 0xff, 0xc1, 0x83,
                                             0xff, 0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x90, 0x00, 0xcc, 0x18, 0x03, 0x00,
                                             0x02, 0x00, 0x86, 0xc0, 0x08, 0x60, 0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0xc0, 0x03, 0x30, 0x00,
                                             0x00, 0x19, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x90, 0x01, 0x98, 0x30, 0x06, 0x00, 0x02, 0x00,
                                             0xc4, 0xfc, 0x08, 0x30, 0x02, 0x40, 0x60, 0x30, 0x00, 0x00, 0xc0, 0x03, 0x18, 0x00, 0x00, 0x19,
                                             0x02, 0x00, 0x27, 0xff, 0x0c, 0x00, 0x80, 0xe1, 0x10, 0x67, 0x0c, 0x00, 0x02, 0x00, 0xc4, 0xc6,
                                             0x08, 0x18, 0x3e, 0x7f, 0xc0, 0x60, 0x00, 0x00, 0x60, 0x06, 0x0c, 0x00, 0x00, 0x19, 0x02, 0x00,
                                             0x60, 0x01, 0x86, 0x00, 0x80, 0xa1, 0x10, 0xcc, 0x18, 0x3c, 0x02, 0x00, 0xc4, 0xc3, 0x08, 0x0c,
                                             0x02, 0x40, 0x00, 0xc0, 0x7f, 0x80, 0x30, 0x0c, 0x06, 0x02, 0x80, 0x19, 0x02, 0x00, 0xc0, 0x00,
                                             0xc3, 0x00, 0x80, 0xe1, 0x11, 0x98, 0x10, 0x42, 0x02, 0x00, 0xc4, 0xc1, 0x08, 0x06, 0x00, 0x00,
                                             0x01, 0x80, 0xc0, 0xc0, 0x38, 0x1c, 0x03, 0xfe, 0xff, 0x00, 0x02, 0x01, 0x80, 0x00, 0x61, 0x00,
                                             0x80, 0x41, 0x11, 0x33, 0x10, 0x81, 0x02, 0x00, 0xc4, 0x01, 0x08, 0x03, 0x00, 0x00, 0x03, 0x01,
                                             0x80, 0x60, 0x0f, 0xf0, 0x00, 0x02, 0x81, 0x80, 0x02, 0x01, 0x00, 0x00, 0x21, 0x00, 0x80, 0x41,
                                             0x11, 0x26, 0x10, 0x81, 0x02, 0x00, 0xc4, 0x01, 0x08, 0x01, 0xe0, 0xff, 0xfe, 0x03, 0x00, 0x30,
                                             0x07, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x02, 0x01, 0x00, 0x00, 0x21, 0x00, 0x80, 0x41, 0x11, 0x24 };




  if (millis() >= fade_time + time + wait_time) {
    fade_time = millis();
    switch_fade2 = switch_fade(switch_fade2);
  }

  if (switch_fade2 == false && millis() < fade_time + time) {
    fade = 2048 * int((millis() - fade_time) * (31.0 / time));  //noninvert// dark to bright
  }
  if (switch_fade2 == true && millis() < fade_time + time) {
    fade = 2048 * int(((fade_time + time) - millis()) * (31.0 / time));  // invert
  }

  tft.drawBitmap(0, 65, CM_stat, 240, 16, fade);
}

bool switch_fade(bool argu) {
  if (argu == false) {
    return true;
  }
  if (argu == true) {
    return false;
  }
}


bool latch = false;
bool flip_flop = false;
bool touch() {
  //latch
  //touch, display, must keep displaying when hold
  //detect taking off
  //detect touch again, display off, must keep off when hold

  if (digitalRead(21) == HIGH && flip_flop == false) {  //diplay when touch or hold
    latch = true;
  }
  if (digitalRead(21) == LOW && latch == true) {  // check for taking off
    flip_flop = true;
  }
  if (digitalRead(21) == HIGH && flip_flop == true) {  // turn off when touched once more
    latch = false;
  }
  if (digitalRead(21) == LOW && latch == false) {  //check for turning off take off
    flip_flop = false;
  }

  return latch;
}

unsigned long mi1;
unsigned long mi2;
int FR_adjust = 0;
void fpslock(int fps, int fr) {
  if (fr > fps) {
    FR_adjust--;
  }
  if (fr < fps) {
    FR_adjust++;
  }

  int intervol = 1000 / fps;
  mi1 = millis();
  mi2 = millis();

  while (mi1 <= mi2 + intervol - FR_adjust) {
    mi1 = millis();
  }
}

int resiscolor(int band) {
  if (band == 0) {
    return 0;  //black
  }
  if (band == 1) {
    return 0x9260;  //brown
  }
  if (band == 2) {
    return 0xf800;  //red
  }
  if (band == 3) {
    return 0xfd20;  //orange
  }
  if (band == 4) {
    return 0xffe0;  // yellow
  }
  if (band == 5) {
    return 0x9e66;  // green
  }
  if (band == 6) {
    return 0x64bd;  // blue
  }
  if (band == 7) {
    return 0x901a;  //violet
  }
  if (band == 8) {
    return 0x9d13;  // grey
  }
  if (band == 9) {
    return 0xffff;  //white
  }
}
